/*********************************************************************************
 * Дан отсортированный массив уникальных чисел. Найти такой индекс i, для которого 
 * A[i] == i (если такой индекс вообще существует)
 ********************************************************************************/

#include "chapter_8.h"

#include <vector>

using namespace std;

namespace ch08 {

// В данном случае классический бинарный поиск. Индексы как и элементы массива
// "отсортированы", и если в каком-то месте значение "обогнало" свой индекс, то
// искать решение нужно слева. И наоборот.
// O(lgN).
int FindMagicIndex(const vector<int>& vec) {
    int left = 0;
    int right = vec.size() - 1;

    while (left <= right) {
        int mid = (left + right) / 2;
        if (vec[mid] == mid) {
            return mid;
        } else if (vec[mid] < mid) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

} // namespace ch08
