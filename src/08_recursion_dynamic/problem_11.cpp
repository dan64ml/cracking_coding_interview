/*********************************************************************************
 * Дано неограниченное количество монет достоинством {25, 10, 5, 1}. Написать код,
 * определяющий количество способов представления суммы N. 
 ********************************************************************************/

#include "chapter_8.h"

#include <vector>

using namespace std;

namespace ch08 {

// Условие содержит неопределенность: не сказано, надо ли считать перестановки комбинаций.
// Т.е. 7 = 1 + 1 + 5 и 7 = 1 + 5 + 1 это один способ или два. Решим оба варианта задачи.
// Здесь считается всё. В сущности простейшая динамика:
// Change(sum) = Change(sum - 25) + Change(sum - 10) + Change(sum - 5) + Change(sum - 1)
// с начальными условиями (sum < 0): 0 и (sum == 0): 1. Второе условие проще понять если
// считать, что это количество способов достичь нулевой суммы имея одну монету.
// Восходящая реализация с мемоизацией. O(sum) память и сложность.
int Change1(int sum) {
    vector<int> mem(sum + 1, -1);
    mem[0] = 1;

    for (int i = 1; i <= sum; ++i) {
        mem[i] = (i - 25 < 0 ? 0 : mem[i - 25])
                + (i - 10 < 0 ? 0 : mem[i - 10])
                + (i - 5 < 0 ? 0 : mem[i - 5])
                + (i - 1 < 0 ? 0 : mem[i - 1]);
    }

    return mem[sum];
}

// Простая рекурсия. Как обычно с динамикой сложнось растет лавинообразно...
int Ch2Helper(int sum, const vector<int>& coins, int idx) {
    if (sum == 0) {
        return 1;
    }
    if (idx == coins.size()) {
        return 0;
    }

    int result = 0;
    for (int i = 0; i * coins[idx] <= sum; ++i) {
        result += Ch2Helper(sum - i * coins[idx], coins, idx + 1);
    }
    return result;
}

// С мемоизацией. Ch2HelperMemo() это в сущности функция текущей суммы и текущего номинала
// монет, которые мы перебираем. Их и используем как аргументы запоминания.
int Ch2HelperMemo(int sum, const vector<int>& coins, int idx, vector<vector<int>>& mem) {
    if (sum == 0) {
        return 1;
    }
    if (idx == coins.size()) {
        return 0;
    }

    if (mem[sum][idx] == -1) {
        mem[sum][idx] = 0;
        for (int i = 0; i * coins[idx] <= sum; ++i) {
            mem[sum][idx] += Ch2Helper(sum - i * coins[idx], coins, idx + 1);
        }
    }
    return mem[sum][idx];
}

// Второе решение считает только уникальные комбинации. Динамика немного
// хитрей: начинаем набирать сумму с крупных монет. Причем перебираем все
// варианты. Например: 20. Вариантов с монетой в 25 нет. Далее идут монеты 10.
// Варианты: 0 монет по 10 + 20 мЕньшими монетами, 1 по 10 + 10 меньшими и
// 2 по 10 + 0 меньшими. Явно видна рекурсия, т.к. мы с каждым шагом уменьшаем
// количество номиналов. Рекурсия останавливается когда sum = 0 или если 
// уже использованы все номиналы монет.
int Change2(int sum) {
    vector<int> coins {25, 10, 5, 1};
    vector<vector<int>> mem(sum + 1, vector<int>(coins.size(), -1));

    //return Ch2Helper(sum, coins, 0);
    return Ch2HelperMemo(sum, coins, 0, mem);
}

} // namespace ch08
