/*********************************************************************************
 * Написать функцию, проверяющую сбалансированность бинарного дерева.
 ********************************************************************************/

#include "chapter_4.h"

#include <cmath>

using namespace std;

namespace ch04 {

int ISTHelper(Node* node) {
    if (!node) {
        return 0;
    }

    int lh = ISTHelper(node->left);
    if (lh == -1) {
        return -1;
    }
    int rh = ISTHelper(node->right);
    if (rh == -1) {
        return -1;
    }

    if (abs(lh - rh) > 1) {
        return -1;
    }

    return max(lh, rh) + 1;
}

// По условию для каждого узла нужно проверить, что левое поддерево не отличается
// по высоте от правого больше чем на единицу. Чистая рекурсия совмещенная с вычислением
// высоты. Сложность O(N), память на рекурсию O(N), в авторском решении ОШИБОЧНАЯ оценка
// O(lgN). Пример - вырожденное дерево, где все элементы левые потомки. Рекурсия сначала
// дойдет до конца этой ветки, т.е. на глубину N.
bool IsTreeBalanced(Node* root) {
    return (ISTHelper(root) != -1);
}

} // namespace ch04
