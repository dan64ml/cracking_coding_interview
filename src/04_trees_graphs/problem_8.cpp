/*********************************************************************************
 * Создать алгоритм поиска первого общего предка двух узлов бинарного дерева. Нужно
 * избежать хранения дополнительных узлов в структурах данных.
 ********************************************************************************/

#include "chapter_4.h"

#include <utility>

using namespace std;

namespace ch04 {

pair<Node*, int> FindAncestorHelper(Node* root, Node* p, Node* q) {
    if (root == nullptr) {
        return {root, 0};
    }

    int c_num = (root == p || root == q) ? 1 : 0;

    auto [l_ptr, l_num] = FindAncestorHelper(root->left, p, q);
    if (l_num == 2) {
        return {l_ptr, l_num};
    } else if (l_num + c_num  == 2) {
        return {root, 2};
    }

    auto [r_ptr, r_num] = FindAncestorHelper(root->right, p, q);
    if (r_num == 2) {
        return {r_ptr, r_num};
    }

    int total = r_num + l_num  + c_num;
    Node* ret_ptr = (total == 2) ? root : nullptr;

    return {ret_ptr, total};
}

// Задача содержит неопределенности, который надо прояснить. Первая - наличие
// указателя на родителя. При наличии задача совсем простая, считаем что его нет.
// Вторая - является ли узел собственным предком. Авторское решение подразумевает
// что да. Это разумное допущение, т.к. оно дает логичное решение в случае, если
// один из узлов - корень.
// Итеративно обходим дерево, фактически inorder (это оптимизирует алгоритм для 
// случая, когда один узел - текущий корень, а второй в левом поддереве). Возвращаем
// количество найденных узлов и адрес предка, если он уже найден. Если на некотором
// шаге находим оба узла, рекурсию прекращаем.
// Сложность O(N) и память O(N) в случае произвольного дерева. Для сбалансированного
// O(lgN).
Node* FindAncestor(Node* root, Node* p, Node* q) {
    auto [ptr, num] = FindAncestorHelper(root, p, q);
    return ptr;
}


} // namespace ch04
