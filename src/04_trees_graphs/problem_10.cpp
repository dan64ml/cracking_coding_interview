/*********************************************************************************
 * Т1 и Т2 - два очень больших бинарных дерева, причем Т1 значительно больше Т2. 
 * Создать алгоритм, проверяющий является Т2 поддеревом Т1.
 ********************************************************************************/

#include "chapter_4.h"

using namespace std;

namespace ch04 {

bool CompareTree(Node* n1, Node* n2) {
    if (n1 == nullptr && n2 == nullptr) {
        return true;
    }

    if (n1 == nullptr || n2 == nullptr) {
        return false;
    }

    if (n1->key != n2->key) {
        return false;
    }

    return CompareTree(n1->left, n2->left) && CompareTree(n1->right, n2->right);
}

bool traverse(Node* node, Node* t2, int depth, int min_height, int t1_height) {
    if (!node || t1_height - depth < min_height) {
        return false;
    }

    if (CompareTree(node, t2)) {
        return true;
    }

    return traverse(node->left, t2, depth + 1, min_height, t1_height)
            || traverse(node->right, t2, depth + 1, min_height, t1_height);
}

// Задача скорее филосовская, чем алгоритмическая. Авторская идея с преобразованием
// деревьев в строки путём preorder обхода с фиксацией нулевых веток академически
// интересна, но с учетом условия задачи очень спорна. Даже int ключи узлов легко
// могут увеличить размер строк до 10*N1 и 10*N2, т.е. по условию до гигантских, и
// поиск подстроки может быть также очень затратным.
// Более логичным выглядит прямой поиск в Т1 подходящего узла и проверка на совпадение
// с Т2 для каждого подходящего случая. Легко доступна оптимизация: можно проверять 
// высоту поддерева и сравнивать с высотой Т2. В случае даже не очень ветвистого дерева
// это исключит значительное количество поддеревьев из "нижней" части веника Т1. 
// Эта оптимизация практически бесплатная - O(N1) для нахождения высоты Т1, т.е. она
// не влияет на асимптотическую стоимость. ВАЖНО! Без хранения информации о высоте в
// КАЖДОМ узле это оптимизация не точная, но для более менее сбалансированного дерева
// работает эффективно.
// Если есть возможность хранить допинформацию в узлах Т1, можно добавить, например,
// количество узлов в правом и левом поддереве. Это позволит еще быстрее отбрасывать 
// не подходящие поддеревья. Цена оптимизации - O(N1 + N2) по сложности и памяти.
bool IsSubTree(Node* t1, Node* t2) {
    if (!t2) {
        return true;
    }

    int h1 = GetTreeHeight(t1);
    int h2 = GetTreeHeight(t2);

    return traverse(t1, t2, 0, h2, h1);
}

} // namespace ch04
