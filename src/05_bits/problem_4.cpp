/*********************************************************************************
 * Дано целое положительное число. Найти ближайшие к нему меньшее и большее числа,
 * имеющие такое же количество единиц.
 ********************************************************************************/

#include "chapter_5.h"

#include <string>

using namespace std;

namespace ch05 {

// Задача в основном на аккуратную реализацию. Основная идея: нужно найти самый
// младший ноль, справа от которого есть единица. Очевидно, что замена нуля единицей
// и единицы нулем даст большее число с тем же количеством единиц. Чтобы получить
// ближайшее большее число, необходимо сдвинуть все единицы (при их наличии), которые
// находятся правее нового нулевого бита, в самые младшие разряды.
// Также важно заметить, что задача может не иметь решения.
// Сложность O(sizeof()).
uint GetNext(uint num) {
    int pos = -1;
    for (size_t i = 0; i < sizeof(num) * 8 - 1; ++i) {
        if ((num & (0x1 << i)) && !(num & (0x1 << (i + 1)))) {
            pos = i;
            break;
        }
    }

    if (pos == -1) {
        return 0;
    }

    uint mask = 0x1 << (pos + 1);
    num |= mask;

    int ones = 0;
    for (int i = 0; i < pos; ++i) {
        if (num & (0x1 << i)) ++ones;
    }

    num &= ~(mask - 1);
    uint tail = (0x1 << ones) - 1;

    return num | tail;
}

// По сути зеркальная копия предыдущей задачи. Чтобы новое число минимально 
// отличалось от исходного опять работаем с младшими разрядами. Нам нужна 
// самая левая единица, справа от которой есть ноль (опять для сохранения числа единиц)
// Опять инвертируем их, но в этот раз хвостовые единицы сдвигаем в другую сторону.
uint GetPrev(uint num) {
    int pos = -1;
    for (size_t i = 0; i < sizeof(num) * 8 - 1; ++i) {
        if (!(num & (0x1 << i)) && (num & (0x1 << (i + 1)))) {
            pos = i;
            break;
        }
    }

    if (pos == -1) {
        return 0;
    }

    num ^= (0x3 << pos);

    int ones = 0;
    for (int i = 0; i < pos; ++i) {
        if (num & (0x1 << i)) ++ones;
    }

    uint mask = ~((0x1 << pos) - 1);
    num &= mask;
    uint tail = (0x1 << ones) - 1;
    tail <<= pos - ones;

    return num | tail;
}


} // namespace ch05
