/*********************************************************************************
 * Дано целое число, в котором можно заменить ровно один бит из 0 в 1. Определить
 * длину самой большой последовательности, которую можно получить.
 ********************************************************************************/

#include "chapter_5.h"

#include <string>

using namespace std;

namespace ch05 {

// Идея алгоритма банальна, главное не запутаться в реализации.
// Пробегаем по битам, считая длину текущей группы. Когда заканчивается
// группа ЕДИНИЦ, проверяем сколько перед ней было нулей (zeros) и какова
// длина предыдущей группы единиц(prev_len). Если zeros == 1, две группы
// можно слить. Вычисляем текущий максимум, сбрасываем счетчики.
// Чтобы не возиться с обновлением максимума после окончания цикла, добавляем
// в коней строки 0.
// Сложность O(lenght).
int FindMaxSequence(uint num) {
    string s;
    while(num) {
        if (num & 0x1) {
            s.push_back('1');
        } else {
            s.push_back('0');
        }

        num >>= 1;
    }

    s += "0";

    int max_len = 1;
    int prev_len = 0;
    int ones = 0;
    int zeros = 0;

    for (auto c : s) {
        if (c == '1') {
            ++ones;
        } else {
            if (ones) {
                if (zeros == 1) {
                    max_len = max(max_len, ones + prev_len + 1);
                } else {
                    max_len = max(max_len, ones + 1);
                }

                zeros = 0;
                prev_len = ones;
                ones = 0;
            }

            ++zeros;
        }
    }

    return max_len;
}

} // namespace ch05
