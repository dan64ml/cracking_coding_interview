/*******************************************************************************
 * Для кольцевого списка реализовать функцию, возвращающую начальный узел петли.
 *******************************************************************************/

#include "chapter_2.h"

using namespace std;

// Решаем методом двух бегунков. Медленный двигаем на один узел за шаг, быстрый на два.
// Если в какой то момент быстрый достигнет конца списка, значит петли нет вовсе. Иначе
// бегунки в какой то момент встретятся. Это гарантированно будет в петле.
// Далее самое интересное: пусть длина петли l, а расстояние до ее начала k. Когда медленный
// бегунок дойдет до начала петли, быстрый пройдет по петле k узлов и будет отставать от медленного
// на l - (k % l). Через такое же расстояние он его догонит и они встретятся в точке l - (k % l) от
// начала петли. Ну или на расстоянии (k % l) ДО начала петли. Запускаем два медленных бегунка из точки
// встречи и из головы списка. Точка их встречи будет началом петли. Сложность O(N).
Node* find_loop(Node* node) {
    Node* sp = node;
    Node* fp = node;

    while (true)
    {
        if (!fp || !fp->pNext) {
            return nullptr;
        } else {
            fp = fp->pNext->pNext;
            sp = sp->pNext;
        }

        if (fp == sp) {
            break;
        }
    }
    
    fp = node;
    while (fp != sp)
    {
        fp = fp->pNext;
        sp = sp->pNext;
    }
    
    return sp;
}